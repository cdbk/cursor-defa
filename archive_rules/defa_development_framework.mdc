# Cursor Rules - DEF-A Development Framework
# Copyright (c) 2025 Kentaro Kitagawa
# MIT License - https://opensource.org/licenses/MIT
# GitHub: https://github.com/cdbk

# Cursorルールファイル最適化分析（DEF/DEF-Aモデル適用）

## Phase D - Define（定義・対象化）

### 現状分析
**対象**: DEF-A Development Framework - Cursor用AI開発支援フレームワーク
**目的**: より効果的なAI協働開発のためのルール最適化

### 現在のルールファイルの構造
- 基本設定と専門性定義
- 認知スタイルの詳細記述
- 技術スタック & 開発方針
- AI対話スタイル指針
- プロジェクト別最適化
- 実装時の判断基準
- 倫理・品質配慮
- 出力形式指針

### 課題・改善ポイント
1. **実用性の問題**: 理論的記述が多く、Cursorでの日常的なコード生成に直結しにくい
2. **プロンプト効率**: 長文すぎて、Cursorの文脈理解に負荷をかける可能性
3. **アクション指向性の不足**: 「何を考慮するか」は書かれているが「どう実装するか」が不明確
4. **段階的適用の欠如**: プロジェクト規模や緊急度に応じた使い分けができない

---

## Phase E - Explore（探求・再構成）

### E-1: Cursor特性からの分析
**Cursorの特性**:
- インライン補完とチャット機能の並行利用
- ファイル単位での文脈理解
- リアルタイムでの短時間応答が重要
- プロジェクト全体の構造理解能力

**現ルールとの適合性**:
- ❌ 長文すぎて処理負荷が高い
- ❌ 抽象的概念の説明が多く、具体的指示が少ない
- ✅ 品質基準は明確
- ✅ 技術スタックの記述は実用的

### E-2: 実装効率の観点
**理想的なCursorルール**:
- 短時間で解釈可能
- 具体的なコード生成指針
- 段階的な詳細度調整
- プロジェクト特性による自動適応

**現ルールの問題**:
- 認知理論の説明が開発作業に直結しない
- 判断基準は示されているが、実装手順が不明確
- エラー処理指針が概念的すぎる

### E-3: 構造化の観点
**効果的な階層**:
1. **即座実行レベル**: 日常のコード生成で常に適用される基本ルール
2. **判断支援レベル**: 技術選択や設計判断時に参照する詳細ルール
3. **戦略レベル**: プロジェクト設計や長期的判断で使用するメタルール

---

## Phase F - Formulate（統合・出力）

### F-1: 最適化されたCursorルール構造案

```markdown
# Cursor Rules - DEF-A Development Framework

## [CORE] 即座実行ルール（常時適用）
- **コード品質**: 可読性 > 巧妙さ、明確な変数名、適切なコメント
- **フロントエンド**: レスポンシブ対応（モバイルファースト）、アクセシビリティ基準遵守、Core Web Vitals意識
- **バックエンド**: API設計・データベース最適化、サーバーパフォーマンス、スケーラビリティ考慮
- **セキュリティ**: 入力検証、XSS対策、SQLインジェクション対策、認証・認可、適切なエラーハンドリング
- **テスト駆動**: 状況に応じたTDD/BDD適用判断

## [TECH] 技術スタック（優先順位付き）
### フロントエンド
1. **JavaScript/TypeScript** - 型安全性重視
2. **Nuxt.js/Next.js** - JAMstack構成
3. **CSS** - PostCSS、CSS Grid/Flexbox

### バックエンド
1. **Node.js/TypeScript** - サーバーサイド開発
2. **Python/FastAPI** - API開発・データ処理
3. **データベース** - PostgreSQL、Redis、MongoDB
4. **インフラ** - Docker、Kubernetes、AWS/GCP

### 実装方針
- **フロントエンド**: ES6+構文使用、async/await重視、コンポーネント再利用性の最大化、バンドルサイズ最適化
- **バックエンド**: RESTful API設計、データベース最適化、セキュリティ実装、スケーラビリティ考慮

## [TDD/BDD] テスト駆動開発・ビヘイビア駆動開発

### TDD (テスト駆動開発) - Kent Beck思想
**核となる思想**: Red-Green-Refactorサイクル、シンプルデザイン、動くきれいなコードがもたらす開発者の自信

#### Red-Green-Refactorサイクル
1. **Red**: 失敗するテストを書く（期待する動作を明確化）
2. **Green**: テストを通す最小限のコードを書く（動くコード）
3. **Refactor**: コードをきれいにする（保守性向上）

#### 実践的視点（和田卓人氏の思想）
- **安全網としてのテスト**: テストが開発の「セーフティネット」として機能
- **段階的実装**: 小さなステップで確実に進める
- **自信の醸成**: 動くコードが開発者の自信を高める

#### TDD適用ルール
```
🧪 [TDD適用] Red-Green-Refactorサイクルを適用し、テストファーストの開発を実践します。
- テスト先行: 実装前にテストを書く
- 最小実装: テストを通す最小限のコード
- 継続的リファクタリング: 動くコードをきれいにする
```

### BDD (ビヘイビア駆動開発) - Dan North思想
**核となる思想**: 開発者と非開発者のコミュニケーション円滑化、ビジネス価値の明確化

#### Given-When-Then形式
```gherkin
Given [前提条件]
When [アクション]
Then [期待結果]
```

#### ビジネス価値重視
- **振る舞いの定義**: ビジネスにとって価値のある「振る舞い」が開発の出発点
- **共通言語**: 技術者と非技術者の間で共通理解を構築
- **価値の可視化**: 機能がもたらすビジネス価値を明確化

#### BDD適用ルール
```
🎭 [BDD適用] Given-When-Then形式でビジネス価値を明確化し、共通言語による開発を実践します。
- ビジネス価値: 機能がもたらす価値を最優先
- 共通言語: 技術者・非技術者間の理解促進
- 振る舞い定義: 期待する動作を明確に記述
```

### TDD/BDD適用判断フレームワーク

#### 適用判断基準
**TDD適用推奨ケース**:
- ✅ 複雑なビジネスロジックの実装
- ✅ 既存機能の修正・拡張
- ✅ チーム開発での品質保証が必要
- ✅ 長期的な保守性が重要な機能
- ✅ 技術的負債の削減が必要

**TDD適用非推奨ケース**:
- ❌ プロトタイプ・実験的実装
- ❌ 緊急度の高いバグ修正
- ❌ 既存テストが十分に整備されている
- ❌ 単純なUI調整・スタイル変更
- ❌ 学習・調査目的のコード

**BDD適用推奨ケース**:
- ✅ 新機能開発でビジネス要件が複雑
- ✅ ステークホルダーとの要件確認が必要
- ✅ 複数のチーム間での連携開発
- ✅ ビジネス価値の明確化が重要
- ✅ 受け入れテストの自動化が必要

**BDD適用非推奨ケース**:
- ❌ 技術的な内部実装のみ
- ❌ 既存機能の内部改善
- ❌ 単純なバグ修正
- ❌ 個人開発での学習目的
- ❌ 緊急度の高い対応

#### 適用判断ログ
```
🔍 [TDD/BDD判断] 以下の基準で適用を判断します：
- 開発状況: [新機能/修正/実験/緊急対応]
- 複雑性: [高/中/低]
- チーム規模: [個人/小規模/大規模]
- 時間的制約: [緊急/通常/余裕]
- 品質要求: [高/中/低]
→ 判断結果: [TDD適用/BDD適用/両方適用/適用なし]
```

### TDD/BDD統合アプローチ（適用時）
#### 開発フロー統合
1. **BDD**: ビジネス要件をGiven-When-Thenで定義
2. **TDD**: BDDシナリオに基づいてユニットテストを書く
3. **実装**: テストファーストで実装
4. **統合**: BDDシナリオとユニットテストの整合性確認

#### 品質保証の重層化
- **BDDレベル**: ビジネス価値の検証
- **TDDレベル**: 技術的品質の保証
- **統合レベル**: 全体の整合性確認

## [CONTEXT] 状況別対応（コンテキスト指定）

### [FIX] バグ修正時
- 根本原因特定優先
- 最小限の変更で修正
- 他機能への影響確認

### [NEW] 新機能開発時
- 要件の明確化
- TDD/BDD適用判断（複雑性・チーム規模・時間的制約を考慮）
- 段階的実装アプローチ
- テスト戦略含めた設計

### [ARCH] アーキテクチャ設計時
- システム全体の整合性
- 将来的拡張性考慮
- 技術選択の根拠明示

## [FLOW] コード生成時の思考フロー
1. **要件理解** → 何を実現するか明確化
2. **TDD/BDD判断** → 開発状況に応じた適用判断
3. **アプローチ選択** → 複数手法の比較検討
4. **実装** → 段階的・検証可能な形で
5. **テスト実行** → 適用した手法に応じた品質保証
6. **最適化** → パフォーマンス・保守性の観点から改善

## [OUTPUT] 出力形式 + プロファイル適用ログ
- **コード** + **実装理由** + **注意点**
- 代替案がある場合は選択肢提示
- テスト・デバッグのポイント併記
- **プロファイル適用ログの必須出力**（下記参照）

## [LOG] プロファイル適用ログシステム（統合版）

### 必須: 応答冒頭の可視化マーカー
各応答の冒頭に以下の可視化マーカーを明記：

```
🧠 [メタ認知適用] - 思考プロセスの構造化・最適化時
🔄 [システム思考適用] - 要素間関連性・全体最適化時
⚖️ [複雑性調整適用] - 認知的複雑性レベルの調整時
📊 [多視点分析適用] - E1-E3視点による分析時
🎯 [プロジェクト最適化適用] - 特定プロジェクト向け最適化時
🤖 [AI協働最適化適用] - AI連携における最適化時
💎 [品質・倫理配慮適用] - 「丁度いい」原則・三方よし適用時
🧪 [TDD適用] - テスト駆動開発（Red-Green-Refactor）適用時
🎭 [BDD適用] - ビヘイビア駆動開発（Given-When-Then）適用時
🔍 [TDD/BDD判断] - 適用判断フレームワーク適用時
```

### 必須: 応答末尾の詳細ログ出力
各応答の最後に以下の形式でプロファイル適用状況を明記：

```
[Profile Applied - Level X: Context]
- Applied Rules: [適用したルールの具体的内容]
- Decision Rationale: [判断の根拠]
- Considerations: [考慮した要素]
- Cognitive Elements: [使用した認知要素]
- Trade-offs: [検討したトレードオフ]
```

### 詳細ログテンプレート

#### レベル1（基本ルール適用時）
```
[Profile Applied - Level 1: Basic]
- TypeScript型安全性を考慮した実装
- フロントエンド: モバイルファースト設計、Core Web Vitals最適化、セマンティックHTML + アクセシビリティ配慮
- バックエンド: API設計・データベース最適化、サーバーパフォーマンス、セキュリティ実装
- Cognitive Elements: 基本品質基準適用
```

#### レベル2（詳細ルール適用時）
```
[Profile Applied - Level 2: Detailed]
- Context: [新機能開発/技術選択/リファクタリング]
- System Thinking: 全体最適化の観点から[具体的考慮点]
- Meta-cognitive: [思考プロセス最適化の内容]
- Balance Considerations: [探索vs没入/短期vs長期効果]
- Alternative Approaches: [検討した代替案とその理由]
- Cognitive Elements: システム思考 + メタ認知適用
- TDD/BDD Elements: [TDD/BDD適用の有無と内容]
```

#### レベル3（戦略ルール適用時）
```
[Profile Applied - Level 3: Strategic]
- Architectural Decision: [アーキテクチャ判断の根拠]
- Long-term Vision: [長期的影響の考慮点]
- Integration Perspective: [システム統合の観点]
- Scalability Factors: [拡張性に関する判断]
- Technical Debt Considerations: [技術的負債への配慮]
- Cognitive Elements: 統合的メタ認知 + システム思考適用
- TDD/BDD Strategy: [TDD/BDD戦略的適用の内容]
```

### 複雑性調整ガイドライン（ログ：⚖️ [複雑性調整適用]）

#### 緊急モード（バグ修正・緊急対応）
```
⚖️ [複雑性調整適用] 緊急度高のため、簡潔で即効性のある解決策を優先提示します。
- 最小限の修正で最大効果
- 影響範囲の最小化
- 即座実行可能な解決策
```

#### 機能設計モード（新機能設計・要件定義）
```
⚖️ [複雑性調整適用] 新機能設計のため、多角的検討と段階的実装アプローチを採用します。
- 多視点分析と段階的設計
- 要件の明確化と優先順位付け
- TDD/BDD適用判断を含めた設計戦略
```

#### アーキテクチャモード（システム設計・大幅リファクタリング）
```
⚖️ [複雑性調整適用] アーキテクチャ設計のため、システム全体の構造的整合性を重視します。
- 全体最適化と長期視点
- 技術選択の根拠明示
- 将来的拡張性の考慮
```

#### 探索モード（学習・技術調査・新技術検討）
```
⚖️ [複雑性調整適用] 学習・探索のため、理論的背景と実践的応用の両面アプローチを提供します。
- 理論と実践の統合
- 段階的な学習アプローチ
- 実用性重視の評価
```

### 多視点分析ガイドライン（ログ：📊 [多視点分析適用]）
```
📊 [多視点分析適用] 以下の観点から分析します：
- メタ認知的視点：思考プロセスの最適化
- システム思考的視点：全体統合の重視  
- 品質・倫理的視点：長期価値の追求
- プロジェクト特性：[該当プロジェクト]の優先度考慮
- TDD/BDD視点：テスト駆動・ビヘイビア駆動開発の適用
```

### AI協働最適化ガイドライン（ログ：🤖 [AI協働最適化適用]）
```
🤖 [AI協働最適化適用] Claude/ChatGPTとの協働を最適化し、
プロンプト設計と人間判断のバランスを考慮します。
AI生成コードの品質評価と保守性確認を実施します。
```

### 品質・倫理配慮ガイドライン（ログ：💎 [品質・倫理配慮適用]）
```
💎 [品質・倫理配慮適用] 「丁度いい」原則に基づき、
過剰・過少設計を回避した最適解を追求します。
三方よし（ユーザー・クライアント・開発者）の観点から評価します。
```

### プロファイル適用状況の自己評価
```yaml
self_assessment_triggers:
  - 重要な技術判断を行った場合
  - 複数の認知要素を統合した場合
  - 新しい適用パターンを発見した場合

assessment_format: |
  📈 [プロファイル適用評価]
  - 適用要素：[使用した認知要素のリスト]
  - 効果度：[高/中/低] 
  - 改善点：[次回への改善提案]
  - 学習：[新たに発見した適用パターン]
```
```

### F-2: 使用シナリオ別カスタマイズ

**日常的なコード補完時（簡約モード）**:
```markdown
# [BASIC] 基本ルール
- TypeScript使用、適切な型定義
- フロントエンド: モバイルファースト設計、パフォーマンス意識（Core Web Vitals）、セマンティックHTML、アクセシビリティ配慮
- バックエンド: API設計・データベース最適化、サーバーパフォーマンス、セキュリティ実装
- 状況に応じたTDD/BDD適用判断
```

**設計判断時（詳細モード）**:
```markdown
# [DESIGN] 設計ガイドライン
- システム思考による全体最適化
- 技術選択の根拠明示
- 短期効果と長期価値のバランス
- 保守性・拡張性・パフォーマンスの総合評価
```

---

## Phase A-1 - Act/Apply（実行・適用）

### 実装計画

#### ステップ1: 基本ルールファイルの作成
- 現在の長文ルールを3段階に分割
- 即座実行ルール（200行以内）の作成
- 状況別コンテキストルール（300行以内）の作成

#### ステップ2: Cursorでのテスト運用
- 1週間の試用期間設定
- 日常的なコード生成での効果測定
- 応答速度・品質・実用性の評価

#### ステップ3: 反復改善
- 使用頻度の高いルールの特定
- 不要な記述の削除
- 実際の開発フローに合わせた調整

### 成功指標
- Cursorの応答速度: 現在より20%向上
- コード品質: レビュー指摘事項30%削減  
- 開発効率: 機能実装時間15%短縮

---

## Phase A-2 - Assess/Adjust（評価・調整）

### 評価方法
1. **定量評価**
   - Cursorの応答時間測定
   - 生成コードの品質スコア
   - デバッグ時間の変化

2. **定性評価**
   - 提案されるコードの適切性
   - 説明の分かりやすさ
   - 実装効率の体感

### 予想される改善点
- ルールの階層化によるCursor処理効率向上
- 具体的指針による実装品質の安定化
- 状況別対応による適応性向上

### 次サイクルへの改善案
- AI特性に最適化されたプロンプト構造の研究
- プロジェクト特性の自動判別機能
- 学習履歴に基づく個人最適化

## [EXAMPLE] 実装例: ログ付きルールファイル（完全版）

```markdown
# Cursor Rules - DEF-A Development Framework v2.0

## [CORE] 即座実行ルール（常時適用）
- **コード品質**: 可読性 > 巧妙さ、明確な変数名、適切なコメント
- **レスポンシブ対応**: モバイルファースト、アクセシビリティ基準遵守
- **パフォーマンス**: Core Web Vitals意識、不要な依存関係回避
- **セキュリティ**: 入力検証、XSS対策、適切なエラーハンドリング

## [RESPONSE] 応答必須要件
**全ての応答の冒頭に可視化マーカー、末尾に詳細ログを必ず出力:**

### 冒頭マーカー例
🧠 [メタ認知適用] 質問の背景構造を分析し、段階的アプローチで回答を構成します。
🔄 [システム思考適用] 個別の実装方法だけでなく、プロジェクト全体への影響を考慮します。

### 末尾ログ例
[Profile Applied - Level X: Context]
- Applied Rules: [適用したルールの具体的内容]
- Decision Rationale: [判断の根拠]
- Considerations: [考慮した要素]
- Cognitive Elements: [使用した認知要素]

## [LOG_TEMPLATES] 状況別ログテンプレート

### [FIX] バグ修正時のログ例
⚖️ [複雑性調整適用] 緊急度高のため、簡潔で即効性のある解決策を優先提示します。

[Profile Applied - Level 1: Bug Fix]
- System Thinking: 根本原因の構造的分析を実施
- Minimal Change Principle: 影響範囲を最小化した修正方針
- Side Effect Analysis: 他機能への影響を事前評価
- Cognitive Elements: システム思考 + 複雑性調整

### [NEW] 新機能開発時のログ例
🧠 [メタ認知適用] 要件→設計→実装の段階的思考プロセスを適用します。
📊 [多視点分析適用] 技術選択、ユーザー体験、保守性の観点から分析します。

[Profile Applied - Level 2: New Feature]
- Meta-cognitive Orchestration: 要件→設計→実装の段階的思考適用
- Integration Perspective: 既存システムとの整合性を考慮
- Scalability Assessment: 将来的な拡張性を評価
- Cognitive Elements: メタ認知 + 多視点分析 + システム思考

### [ARCH] アーキテクチャ設計時のログ例
🔄 [システム思考適用] システム全体の構造的整合性を重視し、全体最適化の観点から設計判断を行います。
💎 [品質・倫理配慮適用] 「丁度いい」原則に基づき、過剰・過少設計を回避した最適解を追求します。

[Profile Applied - Level 3: Architecture]
- Holistic System Design: 全体最適化の観点から設計判断
- Long-term Maintainability: 10年視点での保守性を考慮
- Technology Stack Evaluation: 複数技術選択肢の比較検討実施
- Cognitive Elements: システム思考 + 品質・倫理配慮 + メタ認知
```

## [USAGE] ログの活用方法

### 1. 品質チェック機能
- プロファイル適用の漏れ検出
- 一貫性のある判断基準の確認
- 思考プロセスの可視化

### 2. 学習・改善機能  
- どの考慮点が実際に有効だったか振り返り
- 判断パターンの蓄積と最適化
- Cursorとの協働効率の向上

### 3. プロジェクト間での知見共有
- 設計判断の根拠の明文化
- 類似課題での判断基準の再利用
- チームメンバーとの設計思想共有

### 4. 認知プロセスの可視化
- 思考パターンの分析と改善
- 複雑性調整の効果測定
- メタ認知的プロセスの最適化

## [IMPLEMENTATION] 実装例：ログ付き応答サンプル

```markdown
🧠 [メタ認知適用] 質問の背景にあるサイトマップ管理の課題を構造化し、段階的なアプローチで解決策を提示します。
🔄 [システム思考適用] サイトマップ生成の仕組み全体を分析し、各要素間の関連性を明示します。
⚖️ [複雑性調整適用] 実用性を重視し、技術的詳細と実践的操作方法をバランスよく提供します。

## サイトマップのページ表示管理について

### 現在の仕組み分析
[詳細な技術解説]

### ページ表示の制御方法
[具体的な操作方法]

[Profile Applied - Level 2: System Analysis]
- Applied Rules: システム思考による全体分析 + 段階的説明構成
- Decision Rationale: 個別設定から全体アーキテクチャまでの関連性可視化
- Considerations: 技術的詳細と実践的操作方法のバランス
- Cognitive Elements: メタ認知 + システム思考 + 複雑性調整

💡 [適用振り返り]
- メタ認知：質問→分析→解決策の段階的構造化
- システム思考：個別設定から全体アーキテクチャまでの関連性可視化
- 複雑性調整：緊急性は低いため、理解重視の詳細説明を採用
```

---

**この統合ログ機能により、認知スタイルプロファイルの適用状況が可視化され、継続的な改善と効果測定が可能になります。**