# Cursor Rules - Testing & Quality Assurance
# Copyright (c) 2025 Kentaro Kitagawa
# MIT License - https://opensource.org/licenses/MIT

## [TESTING] テスト駆動開発・品質保証ガイドライン

### TDD (テスト駆動開発) - Kent Beck思想

#### Red-Green-Refactorサイクル
1. **Red**: 失敗するテストを書く（期待する動作を明確化）
2. **Green**: テストを通す最小限のコードを書く（動くコード）
3. **Refactor**: コードをきれいにする（保守性向上）

#### 実践的視点（和田卓人氏の思想）
- **安全網としてのテスト**: テストが開発の「セーフティネット」として機能
- **段階的実装**: 小さなステップで確実に進める
- **自信の醸成**: 動くコードが開発者の自信を高める

#### TDD適用ルール
```
🧪 [TDD適用] Red-Green-Refactorサイクルを適用し、テストファーストの開発を実践します。
- テスト先行: 実装前にテストを書く
- 最小実装: テストを通す最小限のコード
- 継続的リファクタリング: 動くコードをきれいにする
```

### BDD (ビヘイビア駆動開発) - Dan North思想

#### Given-When-Then形式
```gherkin
Given [前提条件]
When [アクション]
Then [期待結果]
```

#### ビジネス価値重視
- **振る舞いの定義**: ビジネスにとって価値のある「振る舞い」が開発の出発点
- **共通言語**: 技術者と非技術者の間で共通理解を構築
- **価値の可視化**: 機能がもたらすビジネス価値を明確化

#### BDD適用ルール
```
🎭 [BDD適用] Given-When-Then形式でビジネス価値を明確化し、共通言語による開発を実践します。
- ビジネス価値: 機能がもたらす価値を最優先
- 共通言語: 技術者・非技術者間の理解促進
- 振る舞い定義: 期待する動作を明確に記述
```

### TDD/BDD適用判断フレームワーク

#### 適用判断基準
**TDD適用推奨ケース**:
- ✅ 複雑なビジネスロジックの実装
- ✅ 既存機能の修正・拡張
- ✅ チーム開発での品質保証が必要
- ✅ 長期的な保守性が重要な機能
- ✅ 技術的負債の削減が必要

**TDD適用非推奨ケース**:
- ❌ プロトタイプ・実験的実装
- ❌ 緊急度の高いバグ修正
- ❌ 既存テストが十分に整備されている
- ❌ 単純なUI調整・スタイル変更
- ❌ 学習・調査目的のコード

**BDD適用推奨ケース**:
- ✅ 新機能開発でビジネス要件が複雑
- ✅ ステークホルダーとの要件確認が必要
- ✅ 複数のチーム間での連携開発
- ✅ ビジネス価値の明確化が重要
- ✅ 受け入れテストの自動化が必要

**BDD適用非推奨ケース**:
- ❌ 技術的な内部実装のみ
- ❌ 既存機能の内部改善
- ❌ 単純なバグ修正
- ❌ 個人開発での学習目的
- ❌ 緊急度の高い対応

#### 適用判断ログ
```
🔍 [TDD/BDD判断] 以下の基準で適用を判断します：
- 開発状況: [新機能/修正/実験/緊急対応]
- 複雑性: [高/中/低]
- チーム規模: [個人/小規模/大規模]
- 時間的制約: [緊急/通常/余裕]
- 品質要求: [高/中/低]
→ 判断結果: [TDD適用/BDD適用/両方適用/適用なし]
```

### テスト戦略・種類

#### ユニットテスト
- **対象**: 個別の関数・メソッド・クラス
- **ツール**: Jest、Vitest、pytest、JUnit
- **カバレッジ**: 80%以上を目標
- **モック**: 外部依存の適切なモック化

#### 統合テスト
- **対象**: 複数コンポーネント間の連携
- **APIテスト**: エンドポイントの動作確認
- **データベーステスト**: データアクセス層の検証
- **外部サービス**: 外部APIとの連携テスト

#### E2Eテスト
- **対象**: ユーザー操作の全体フロー
- **ツール**: Playwright、Cypress、Selenium
- **シナリオ**: 重要なユーザージャーニー
- **環境**: 本番に近い環境での実行

#### パフォーマンステスト
- **負荷テスト**: 高負荷時の動作確認
- **ストレステスト**: 限界値での動作確認
- **ツール**: k6、Artillery、JMeter
- **メトリクス**: レスポンス時間、スループット

### テスト設計原則

#### AAAパターン（Arrange-Act-Assert）
```typescript
// Arrange: テストの準備
const user = createTestUser();
const service = new UserService();

// Act: テスト対象の実行
const result = service.createUser(user);

// Assert: 結果の検証
expect(result).toBeDefined();
expect(result.id).toBeTruthy();
```

#### テストデータ管理
- **ファクトリーパターン**: テストデータの生成
- **フィクスチャ**: 事前定義されたテストデータ
- **クリーンアップ**: テスト後の状態復元
- **データベース**: テスト用DBの分離

#### モック・スタブ戦略
- **モック**: 外部依存の動作を模擬
- **スタブ**: 簡易的な実装で置き換え
- **スパイ**: メソッド呼び出しの監視
- **適切な使用**: 過度なモック化を避ける

### 品質保証プロセス

#### コードレビュー
- **プルリクエスト**: 必須レビュープロセス
- **チェックリスト**: 品質基準の確認
- **自動化**: CI/CDパイプラインでの自動チェック
- **継続的改善**: レビュープロセスの最適化

#### 静的解析
- **ESLint**: JavaScript/TypeScriptの品質チェック
- **SonarQube**: コード品質の総合分析
- **TypeScript**: 型安全性の確保
- **Prettier**: コードフォーマット統一

#### 継続的インテグレーション
- **自動テスト**: コミット時の自動実行
- **ビルド検証**: コンパイル・ビルドの確認
- **デプロイメント**: 自動デプロイの検証
- **通知**: 失敗時の適切な通知

### テスト環境・ツール

#### 開発環境
- **ローカルテスト**: 開発時の即座実行
- **Docker**: 一貫したテスト環境
- **環境変数**: テスト用設定の管理
- **データベース**: テスト用DBの自動セットアップ

#### CI/CD統合
- **GitHub Actions**: 自動テスト実行
- **Jenkins**: 継続的インテグレーション
- **テストレポート**: 結果の可視化
- **カバレッジ**: テストカバレッジの測定

### テストメンテナンス

#### テストコードの品質
- **可読性**: 理解しやすいテストコード
- **保守性**: 変更に強いテスト設計
- **実行速度**: 高速なテスト実行
- **信頼性**: 安定したテスト結果

#### テスト戦略の継続的改善
- **効果測定**: テストの効果を定期的に評価
- **技術更新**: 新しいテストツールの導入
- **プロセス改善**: テストプロセスの最適化
- **チーム教育**: テスト技術の共有・向上 